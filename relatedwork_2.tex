\section{Related Work}
The problem of designing efficient mechanisms to ensure strong consistency semantics in geo-replicated data stores has garnered considerable interest in both industry and academy. Two notable examples are Spanner \cite{spanner} and SDUR \cite{scatter}, which  provide strongly consistent transactions via the use of Two-phase commit and Paxos. As already mentioned, \specula builds on state of the art partially replicated geo-distributed data stores, with which it shares several design decisions that contribute to its efficiency and scalability. However, it extends them with innovative speculative concurrency control techniques.

The literature has explored a number of alternative approaches to mitigate, or even possibly avoid, the costs of inter-data-center synchronization in geo-replicated data stores. A first class of approaches consists of protocols  optimized on the basis of the assumption that data is fully replicated across different data-centers, i.e., each data-center maintains a full image of the system's data. To this end, Replicated Commit~\cite{mahmoud2013low} runs Two-Phase Commit multiple times
in different datacenters and then uses Paxos to reach consensus as to whether the transaction should commit; MDCC~\cite{kraska2013mdcc} uses Generalized Paxos \cite{lamport2005generalized} to commit transaction, which takes only a single WAN round-trip in normal case. Unlike these works, \specula supports a more generic and scalable data-model, in which data can be partially replicated across a subset of the available data-centers.

 
 Other recent approaches~\cite{zhang2013transaction,swiftcloud,sovran2011transactional} have aimed to reduce the cost of enforcing strong consistency, e.g., by identifying (possibly in a semi-automatic way) and exploiting the presence of commutative operations that can be executed without endangering consistency (as they are guaranteed  to never conflict). Bumper~\cite{diegues2013bumper}  focuses on the problem of contention hot-spots, allowing to postpone the execution of conflict-prone operations issued within a transaction till their commit phase --- where they are executed after having acquired all the locks they require, and hence without risking to incur aborts. These approaches are orthogonal to \specula and  these mechanisms  could be combined with the speculative techniques  at the heart of \specula's replication protocol to further enhance its performance.
 
Reducing the cost of inter-replica synchronization by relaxing the consistency semantics  provided to applications is another well-explored idea in the literature. Gemini~\cite{li2012making}, for instance, requires programmers to analyze applications and identify (possibly with the aid of static analysis tools~\cite{li2014automating}) which subset of application's operations commute and can safely take advantage of weak consistency semantics.  Unlike \specula, Gemini, assumes a fully replicated data model and, as such, it does not address the issue of how to achieve isolation in presence of operations/transactions that require accessing  multiple data items scattered across different machines (see Figures~\ref{fig:ex1} and~\ref{fig:ex2}). 

Kraska et. al. allows programmers to specify which data shards demand strong consistency (serializability)  and which ones can  tolerate weak semantics (session guarantees), albeit possibly at some cost. This information is then exploited to dynamically adapt the consistency provided to transactions and reach an optimal balance between consistency and latency \cite{kraska2009consistency}. This approach only guarantees the weakest consistency semantics to transactions that access both weakly and strongly consistent data shards. Conversely, \specula ensures strong consistency semantics, as specified by the SPSI criterion, in 

Xie et. al.~\cite{xie2014salt} propose Salt Isolation, which allows classic ACID transactions to co-exist with BASE transactions, i.e., weakly consistent transactions that can externalize their intermediate state to minimize lock duration. Analogously to SPSI, Salt ensures that strong consistent transactions are not affected by the execution of weak consistent ones. However,  \specula ensures that \textit{any} transaction always observes and produces atomic and isolated snapshots, although potentially not reflecting the execution of concurrent transactions originated at different nodes. As discussed in \S \ref{sec:introduction}, this design choice spares programmers from the complexity of reasoning on subtle concurrency bugs that may lead applications running in non-sand-boxed environments  to exhibit arbitrary behaviours~\cite{guerraoui2007opacity, imbs2012virtual}: this is the case, for instance, of applications that do not access data via well-defined query languages, like SQL, but rather by embedding transactions into arbitrary code written in a general purpose programming language, like Java~\cite{javaPersistenceAPI}. In the former case, inconsistencies lead to stale data being returned, but will not cause the data-store to crash. In the latter case, instead, inconsistencies can lead applications to crash because of unexpected exceptions or to enter infinite loops~\cite{felber2008transactions}. 


The idea of exposing, in a speculative fashion, the post-image produced by locally, but not yet globally, certified transactions is not new in the literature. The programming model exposed by PLANET \cite{pang2014planet}, analogously to \specula's,  aims to reduce the user-perceived latency by letting programmers expose the results of speculatively committed transactions. Unlike \specula, though, PLANET relies on a conventional/non-speculative data replication scheme that  never exposes pre-committed data to transactions. As such, PLANET can only benefit user-perceived latency, but fails to reduce the transaction's blocking time and, hence, to enhance throughput and reduce the time it takes to finalize the processing of a transaction. 
The idea of letting transactions ``optimistically'' borrow, in a controlled manner, the updated data of transactions currently in their commit phase has already been investigated in the past. Several works, e.g., SPECULA \cite{peluso2012specula} and Aggro \cite{palmieri2010aggro}, have applied this idea in contexts that are radically different from the ones considered in this paper, i.e.,  small scale clusters in which  data is fully replicated via total-order based coordination primitives. Conversely, \specula is designed for partially replicated data-stores distributed over geographical scale that ensure consistency via Two-phase commit.  SCC-kS~\cite{bestavros1996value}, PROMPT~\cite{PROMPT} and SL~\cite{Reddy} target a relatively closer system model, i.e., distributed databases, but do not support data replication and multi-version concurrency control. These are two mechanisms that are regarded as essential in modern, large scale online services~\cite{spanner,baker2011megastore,peluso2012score}. Further, some of these proposals ~\cite{bestavros1996value, Romano-2014} rely on complex graph-based concurrency control techniques, whose efficiency has also been evaluated via simulation and that are likely to suffer from large overheads in realistic settings. Finally, unlike \specula, PROMPT, SL and SCC-kS may expose non-atomic/isolated snapshots during transaction's execution.